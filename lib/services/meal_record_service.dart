import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../utils/logger.dart';
import 'transaction_service.dart';

/// Modern meal record service for the improved Firebase structure
/// Manages meals in the 'meals' collection
class MealRecordService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Create a meal record
  static Future<Map<String, dynamic>> createMealRecord({
    required String userId,
    required DateTime date,
    required int mealNumber, // 1=breakfast, 2=lunch, 3=dinner, 4=snack
    required double cost,
    String? imageUrl,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      AppLogger.info('Creating meal record for: $userId, date: ${date.toString().split(' ')[0]}, meal: $mealNumber, cost: â‚®$cost');

      final mealRef = _firestore.collection('meals').doc();
      
      final mealData = {
        'userId': userId,
        'date': _formatDate(date),
        'mealNumber': mealNumber,
        'cost': cost,
        'imageUrl': imageUrl,
        'status': 'pending', // pending, confirmed, cancelled
        'metadata': {
          'mealType': _getMealTypeName(mealNumber),
          'autoGenerated': false,
          ...?metadata,
        },
        'timestamps': {
          'createdAt': FieldValue.serverTimestamp(),
          'consumedAt': Timestamp.fromDate(date),
        },
      };

      await mealRef.set(mealData);

      AppLogger.success('Meal record created successfully: ${mealRef.id}');
      
      return {
        'success': true,
        'mealId': mealRef.id,
        'userId': userId,
        'date': _formatDate(date),
        'mealNumber': mealNumber,
        'cost': cost,
        'status': 'pending',
      };
    } catch (error) {
      AppLogger.error('Error creating meal record: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Confirm a meal and process payment
  static Future<Map<String, dynamic>> confirmMeal({
    required String mealId,
    String? transactionId,
  }) async {
    try {
      AppLogger.info('Confirming meal: $mealId');

      return await _firestore.runTransaction((transaction) async {
        final mealDocRef = _firestore.collection('meals').doc(mealId);
        final mealDoc = await transaction.get(mealDocRef);

        if (!mealDoc.exists) {
          throw Exception('Meal record not found');
        }

        final mealData = mealDoc.data()!;
        final userId = mealData['userId'] as String;
        final cost = (mealData['cost'] as num).toDouble();
        final currentStatus = mealData['status'] as String;

        if (currentStatus == 'confirmed') {
          throw Exception('Meal already confirmed');
        }

        // Create purchase transaction if not already done
        String? finalTransactionId = transactionId;
        if (finalTransactionId == null) {
          final purchaseResult = await TransactionService.createPurchase(
            userId: userId,
            amount: cost,
            description: 'Meal purchase - ${_getMealTypeName(mealData['mealNumber'])}',
            mealId: mealId,
            metadata: {
              'mealDate': mealData['date'],
              'mealNumber': mealData['mealNumber'],
            },
          );

          if (!purchaseResult['success']) {
            throw Exception('Failed to process meal payment: ${purchaseResult['error']}');
          }

          finalTransactionId = purchaseResult['transactionId'];
        }

        // Update meal status
        transaction.update(mealDocRef, {
          'status': 'confirmed',
          'transactionId': finalTransactionId,
          'timestamps.confirmedAt': FieldValue.serverTimestamp(),
          'timestamps.updatedAt': FieldValue.serverTimestamp(),
        });

        AppLogger.success('Meal confirmed successfully: $mealId with transaction: $finalTransactionId');

        return {
          'success': true,
          'mealId': mealId,
          'transactionId': finalTransactionId,
          'status': 'confirmed',
          'cost': cost,
        };
      });
    } catch (error) {
      AppLogger.error('Error confirming meal: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Cancel a meal record
  static Future<Map<String, dynamic>> cancelMeal({
    required String mealId,
    String reason = 'User cancelled',
  }) async {
    try {
      AppLogger.info('Cancelling meal: $mealId, reason: $reason');

      return await _firestore.runTransaction((transaction) async {
        final mealDocRef = _firestore.collection('meals').doc(mealId);
        final mealDoc = await transaction.get(mealDocRef);

        if (!mealDoc.exists) {
          throw Exception('Meal record not found');
        }

        final mealData = mealDoc.data()!;
        final currentStatus = mealData['status'] as String;
        final existingTransactionId = mealData['transactionId'] as String?;

        if (currentStatus == 'cancelled') {
          throw Exception('Meal already cancelled');
        }

        // If meal was confirmed and paid, create refund
        if (currentStatus == 'confirmed' && existingTransactionId != null) {
          final cost = (mealData['cost'] as num).toDouble();
          final userId = mealData['userId'] as String;

          final refundResult = await TransactionService.createRefund(
            userId: userId,
            amount: cost,
            originalTransactionId: existingTransactionId,
            reason: 'Meal cancelled: $reason',
            metadata: {
              'mealId': mealId,
              'mealDate': mealData['date'],
            },
          );

          if (!refundResult['success']) {
            AppLogger.warning('Failed to create refund for cancelled meal: ${refundResult['error']}');
          }
        }

        // Update meal status
        transaction.update(mealDocRef, {
          'status': 'cancelled',
          'cancellationReason': reason,
          'timestamps.cancelledAt': FieldValue.serverTimestamp(),
          'timestamps.updatedAt': FieldValue.serverTimestamp(),
        });

        AppLogger.success('Meal cancelled successfully: $mealId');

        return {
          'success': true,
          'mealId': mealId,
          'status': 'cancelled',
          'reason': reason,
        };
      });
    } catch (error) {
      AppLogger.error('Error cancelling meal: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Get meal records for a user with pagination and filters
  static Future<Map<String, dynamic>> getMealRecords({
    String? userId,
    DateTime? startDate,
    DateTime? endDate,
    String? status, // 'pending', 'confirmed', 'cancelled'
    int? mealNumber,
    int limit = 20,
    DocumentSnapshot? lastDocument,
  }) async {
    try {
      final String uid = userId ?? FirebaseAuth.instance.currentUser?.uid ?? '';
      
      if (uid.isEmpty) {
        throw Exception('No user ID provided');
      }

      AppLogger.info('Fetching meal records for: $uid, limit: $limit');

      Query query = _firestore
          .collection('meals')
          .where('userId', isEqualTo: uid)
          .orderBy('timestamps.consumedAt', descending: true)
          .limit(limit);

      // Add filters if provided
      if (status != null) {
        query = query.where('status', isEqualTo: status);
      }

      if (mealNumber != null) {
        query = query.where('mealNumber', isEqualTo: mealNumber);
      }

      if (startDate != null) {
        query = query.where('timestamps.consumedAt', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('timestamps.consumedAt', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      if (lastDocument != null) {
        query = query.startAfterDocument(lastDocument);
      }

      final querySnapshot = await query.get();
      
      final meals = querySnapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return {
          'id': doc.id,
          'userId': data['userId'],
          'date': data['date'],
          'mealNumber': data['mealNumber'],
          'mealType': _getMealTypeName(data['mealNumber']),
          'cost': data['cost'],
          'imageUrl': data['imageUrl'],
          'status': data['status'],
          'transactionId': data['transactionId'],
          'cancellationReason': data['cancellationReason'],
          'metadata': data['metadata'] ?? {},
          'timestamps': data['timestamps'] ?? {},
          'createdAt': data['timestamps']?['createdAt'],
          'consumedAt': data['timestamps']?['consumedAt'],
          'confirmedAt': data['timestamps']?['confirmedAt'],
          'cancelledAt': data['timestamps']?['cancelledAt'],
        };
      }).toList();

      AppLogger.info('Found ${meals.length} meal records for user: $uid');

      return {
        'success': true,
        'meals': meals,
        'count': meals.length,
        'hasMore': meals.length == limit,
        'lastDocument': querySnapshot.docs.isNotEmpty ? querySnapshot.docs.last : null,
      };
    } catch (error) {
      AppLogger.error('Error getting meal records: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Get daily meal summary for a specific date
  static Future<Map<String, dynamic>> getDailyMealSummary({
    required String userId,
    required DateTime date,
  }) async {
    try {
      final dateStr = _formatDate(date);
      AppLogger.info('Getting daily meal summary for: $userId, date: $dateStr');

      final query = _firestore
          .collection('meals')
          .where('userId', isEqualTo: userId)
          .where('date', isEqualTo: dateStr)
          .orderBy('mealNumber');

      final querySnapshot = await query.get();
      
      final meals = querySnapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return {
          'id': doc.id,
          'mealNumber': data['mealNumber'],
          'mealType': _getMealTypeName(data['mealNumber']),
          'cost': data['cost'],
          'status': data['status'],
          'imageUrl': data['imageUrl'],
        };
      }).toList();

      // Calculate summary statistics
      final confirmedMeals = meals.where((meal) => meal['status'] == 'confirmed').toList();
      final totalCost = confirmedMeals.fold(0.0, (total, meal) => total + (meal['cost'] as num).toDouble());
      
      return {
        'success': true,
        'date': dateStr,
        'meals': meals,
        'summary': {
          'totalMeals': meals.length,
          'confirmedMeals': confirmedMeals.length,
          'pendingMeals': meals.where((meal) => meal['status'] == 'pending').length,
          'cancelledMeals': meals.where((meal) => meal['status'] == 'cancelled').length,
          'totalCost': totalCost,
          'averageCostPerMeal': confirmedMeals.isNotEmpty ? totalCost / confirmedMeals.length : 0.0,
        },
      };
    } catch (error) {
      AppLogger.error('Error getting daily meal summary: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Get meal statistics for a user over a date range
  static Future<Map<String, dynamic>> getMealStatistics({
    String? userId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final String uid = userId ?? FirebaseAuth.instance.currentUser?.uid ?? '';
      
      if (uid.isEmpty) {
        throw Exception('No user ID provided');
      }

      Query query = _firestore
          .collection('meals')
          .where('userId', isEqualTo: uid);

      if (startDate != null) {
        query = query.where('timestamps.consumedAt', isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
      }

      if (endDate != null) {
        query = query.where('timestamps.consumedAt', isLessThanOrEqualTo: Timestamp.fromDate(endDate));
      }

      final querySnapshot = await query.get();
      
      double totalCost = 0.0;
      int totalMeals = 0;
      int confirmedMeals = 0;
      int pendingMeals = 0;
      int cancelledMeals = 0;
      Map<int, int> mealTypeCount = {1: 0, 2: 0, 3: 0, 4: 0}; // breakfast, lunch, dinner, snack
      Map<int, double> mealTypeCost = {1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0};

      for (final doc in querySnapshot.docs) {
        final data = doc.data() as Map<String, dynamic>;
        final status = data['status'] as String;
        final cost = (data['cost'] as num).toDouble();
        final mealNumber = data['mealNumber'] as int;

        totalMeals++;
        mealTypeCount[mealNumber] = (mealTypeCount[mealNumber] ?? 0) + 1;

        switch (status) {
          case 'confirmed':
            confirmedMeals++;
            totalCost += cost;
            mealTypeCost[mealNumber] = (mealTypeCost[mealNumber] ?? 0.0) + cost;
            break;
          case 'pending':
            pendingMeals++;
            break;
          case 'cancelled':
            cancelledMeals++;
            break;
        }
      }

      return {
        'success': true,
        'statistics': {
          'totalMeals': totalMeals,
          'confirmedMeals': confirmedMeals,
          'pendingMeals': pendingMeals,
          'cancelledMeals': cancelledMeals,
          'totalCost': totalCost,
          'averageCostPerMeal': confirmedMeals > 0 ? totalCost / confirmedMeals : 0.0,
          'mealTypeBreakdown': {
            'breakfast': {'count': mealTypeCount[1], 'cost': mealTypeCost[1]},
            'lunch': {'count': mealTypeCount[2], 'cost': mealTypeCost[2]},
            'dinner': {'count': mealTypeCount[3], 'cost': mealTypeCost[3]},
            'snack': {'count': mealTypeCount[4], 'cost': mealTypeCost[4]},
          },
          'confirmationRate': totalMeals > 0 ? (confirmedMeals / totalMeals * 100) : 0.0,
          'cancellationRate': totalMeals > 0 ? (cancelledMeals / totalMeals * 100) : 0.0,
        },
        'period': {
          'startDate': startDate?.toIso8601String(),
          'endDate': endDate?.toIso8601String(),
        },
      };
    } catch (error) {
      AppLogger.error('Error getting meal statistics: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Update meal record
  static Future<Map<String, dynamic>> updateMealRecord({
    required String mealId,
    double? cost,
    String? imageUrl,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      AppLogger.info('Updating meal record: $mealId');

      final updateData = <String, dynamic>{
        'timestamps.updatedAt': FieldValue.serverTimestamp(),
      };

      if (cost != null) {
        updateData['cost'] = cost;
      }

      if (imageUrl != null) {
        updateData['imageUrl'] = imageUrl;
      }

      if (metadata != null) {
        updateData['metadata'] = metadata;
      }

      await _firestore.collection('meals').doc(mealId).update(updateData);

      AppLogger.success('Meal record updated successfully: $mealId');
      
      return {'success': true, 'mealId': mealId};
    } catch (error) {
      AppLogger.error('Error updating meal record: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  /// Get meal record by ID
  static Future<Map<String, dynamic>> getMealRecord(String mealId) async {
    try {
      final doc = await _firestore.collection('meals').doc(mealId).get();
      
      if (!doc.exists) {
        return {'success': false, 'error': 'Meal record not found'};
      }

      final data = doc.data()!;
      return {
        'success': true,
        'meal': {
          'id': doc.id,
          'userId': data['userId'],
          'date': data['date'],
          'mealNumber': data['mealNumber'],
          'mealType': _getMealTypeName(data['mealNumber']),
          'cost': data['cost'],
          'imageUrl': data['imageUrl'],
          'status': data['status'],
          'transactionId': data['transactionId'],
          'cancellationReason': data['cancellationReason'],
          'metadata': data['metadata'] ?? {},
          'timestamps': data['timestamps'] ?? {},
        },
      };
    } catch (error) {
      AppLogger.error('Error getting meal record: $error');
      return {'success': false, 'error': error.toString()};
    }
  }

  // Helper methods
  static String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  static String _getMealTypeName(int mealNumber) {
    switch (mealNumber) {
      case 1:
        return 'breakfast';
      case 2:
        return 'lunch';
      case 3:
        return 'dinner';
      case 4:
        return 'snack';
      default:
        return 'unknown';
    }
  }

  static int _getMealNumberFromType(String mealType) {
    switch (mealType.toLowerCase()) {
      case 'breakfast':
        return 1;
      case 'lunch':
        return 2;
      case 'dinner':
        return 3;
      case 'snack':
        return 4;
      default:
        return 1; // Default to breakfast
    }
  }
}